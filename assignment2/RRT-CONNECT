import numpy as np
import matplotlib.pyplot as plt
from matplotlib import patches
import time


def is_in_obstacle(point,obstacles):
    px, py = point

    for (ox, oy), (w, h) in obstacles:
        dx = px - ox
        dy = py - oy
        if abs(dx) <= w / 2 and abs(dy) <= h / 2:
            return True
    return False

def sample(X,obstacles,iterations,random_node=None):
    while random_node is None or is_in_obstacle(random_node,obstacles):
        random_node = (np.random.uniform(*X[0]), np.random.uniform(*X[1]))
        iterations += 1
    return random_node, iterations

def find_nearest_node(nodes, point):
    return min(nodes, key=lambda node: distance(node, point))

def distance(node1, node2):
    return np.hypot(node1[0] - node2[0], node1[1] - node2[1])

def step(nearest, point, step_size):
    cost = distance(nearest, point)
    if cost < step_size:
        return point,cost
    angle = np.atan2(point[1] - nearest[1], point[0] - nearest[0])
    x = nearest[0] + step_size * np.cos(angle)
    y = nearest[1] + step_size * np.sin(angle)
    return (x, y),step_size

def is_edge_valid(node1, node2, obstacles):
    steps = 20
    for i in range(1,steps + 1):
        t = i / steps
        x = node1[0] + t * (node2[0] - node1[0])
        y = node1[1] + t * (node2[1] - node1[1])
        if is_in_obstacle((x, y), obstacles):
            return False
    return True

def  build_RRT_CONNECT(start,goal,xlim,ylim,obstacles,step_size,trial,plot = False):
    # with plot on
    np.random.seed(trial)

    def RRT(nodes, edges, solution_length,iterations):
            if plot:
                random_node, iterations = sample(X,obstacles,iterations)
                nearest_node = find_nearest_node(nodes,random_node)
                new_node,cost = step(nearest_node, random_node, step_size)
                if is_edge_valid(nearest_node,new_node,obstacles):
                    nodes.append(new_node)
                    edges.append((nearest_node,new_node))
                    cost = solution_length[nearest_node]+ cost
                    solution_length[new_node] = cost
                    plt.plot([nearest_node[0], new_node[0]], [nearest_node[1], new_node[1]], color='black')  
                    plt.plot(new_node[0], new_node[1], 'go', markersize=2)
                return nodes, edges, solution_length,new_node,iterations
            else:
                random_node, iterations = sample(X,obstacles,iterations)
                nearest_node = find_nearest_node(nodes,random_node)
                new_node,cost = step(nearest_node, random_node, step_size)
                if is_edge_valid(nearest_node,new_node,obstacles):
                    nodes.append(new_node)
                    edges.append((nearest_node,new_node))
                    cost = solution_length[nearest_node]+ cost
                    solution_length[new_node] = cost
                return nodes, edges, solution_length,new_node,iterations
    def connect(nodes, edges, solution_length, new_node_tree,iterations):
            if plot:
                nearest_node = find_nearest_node(nodes,new_node_tree)
                while True:
                    new_node,cost = step(nearest_node, new_node_tree, step_size)
                    is_edge_valid_test = is_edge_valid(nearest_node,new_node,obstacles)
                    iterations += 1
                    if is_edge_valid_test:
                        nodes.append(new_node)
                        edges.append((nearest_node,new_node))
                        cost = solution_length[nearest_node]+ cost
                        solution_length[new_node] = cost
                        plt.plot([nearest_node[0], new_node[0]], [nearest_node[1], new_node[1]], color='black')  
                        plt.plot(new_node[0], new_node[1], 'go', markersize=2)
                        nearest_node = new_node
                    if  not ((new_node != new_node_tree) and (is_edge_valid_test)):
                        break
                return nodes, edges, solution_length,iterations
            else:
                nearest_node = find_nearest_node(nodes,new_node_tree)
                while True:
                    new_node,cost = step(nearest_node, new_node_tree, step_size)
                    is_edge_valid_test = is_edge_valid(nearest_node,new_node,obstacles)
                    iterations += 1
                    if is_edge_valid_test:
                        nodes.append(new_node)
                        edges.append((nearest_node,new_node))
                        cost = solution_length[nearest_node]+ cost
                        solution_length[new_node] = cost
                        nearest_node = new_node
                    if  not ((new_node != new_node_tree) and (is_edge_valid_test)):
                        break
                return nodes, edges, solution_length,iterations
    if plot:
        plt.plot(*start, 'bo', markersize=8, label="Start")
        plt.plot(*goal, 'ro', markersize=8, label="Goal")
        plt.xlim(xlim)
        plt.ylim(ylim)
        plt.title("RRT in progress")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.legend()

        ax = plt.gca()
        for (ox, oy), (w, h) in obstacles:
            
            rect = patches.Rectangle((ox - w/2, oy - h/2), w, h, color='gray')
            
            ax.add_patch(rect)

        X = [xlim, ylim]

        nodes_start = [start]
        edges_start = []
        nodes_goal = [goal]
        edges_goal = []
        solution_length_start = {start: 0}
        solution_length_goal = {goal: 0}

        iterations = 0
        turn = "start"
        
        
        
        
                
        while not any(node in nodes_goal for node in nodes_start):
            if turn == "start":
                nodes_start, edges_start, solution_length_start,new_node,iterations = RRT(nodes_start, edges_start, solution_length_start,iterations)
                nodes_goal, edges_goal, solution_length_goal,iterations = connect(nodes_goal, edges_goal, solution_length_goal, new_node,iterations)
            if turn == "goal":
                nodes_goal, edges_goal, solution_length_goal,new_node,iterations = RRT(nodes_goal, edges_goal, solution_length_goal,iterations)
                nodes_start, edges_start, solution_length_start,iterations = connect(nodes_start, edges_start, solution_length_start, new_node,iterations)
            turn = "goal" if turn == "start" else "start"
        
                
        solution_length = solution_length_goal[new_node] + solution_length_start[new_node]
        node = new_node
        path = []
        while node != start:
            edge = None
            for (n1, n2) in edges_start:
                if n2 == node:
                    edge = (n1, n2)
                    break
            if edge in edges_start:
                path.append(edge)
            node = n1
        path.reverse()
        node = new_node
        while node != goal:
            edge = None
            for (n1, n2) in edges_goal:
                if n2 == node:
                    edge = (n1, n2)
                    break
            if edge in edges_goal:
                path.append(edge)
            node = n1
        
        for (p, c) in path:   # go from start â†’ goal
            x1, y1 = p
            x2, y2 = c
            plt.plot([x1, x2], [y1, y2], 'r-')  
            
        nodes_number = len(nodes_start)+len(nodes_goal)
        plt.title(f"RRT-Connect Finished - Trial number {trial+1}")
        print("Iterations:",iterations)
        print("Vertices:",nodes_number)
        print("Solution length:", solution_length)
        plt.show()
        return iterations, nodes_number, solution_length
    
    #without plot on
    X = [xlim, ylim]

    nodes_start = [start]
    edges_start = []
    nodes_goal = [goal]
    edges_goal = []
    solution_length_start = {start: 0}
    solution_length_goal = {goal: 0}

    iterations = 0
    turn = "start"

    while not any(node in nodes_goal for node in nodes_start):
            if turn == "start":
                nodes_start, edges_start, solution_length_start,new_node,iterations = RRT(nodes_start, edges_start, solution_length_start,iterations)
                nodes_goal, edges_goal, solution_length_goal,iterations = connect(nodes_goal, edges_goal, solution_length_goal, new_node,iterations)
            if turn == "goal":
                nodes_goal, edges_goal, solution_length_goal,new_node,iterations = RRT(nodes_goal, edges_goal, solution_length_goal,iterations)
                nodes_start, edges_start, solution_length_start,iterations = connect(nodes_start, edges_start, solution_length_start, new_node,iterations)
            turn = "goal" if turn == "start" else "start"

    solution_length = solution_length_goal[new_node] + solution_length_start[new_node]

    nodes_number = len(nodes_start)+len(nodes_goal)

 
    print("Iterations:",iterations)
    print("Vertices:",nodes_number)
    print("Solution length:", solution_length)

    return iterations, nodes_number, solution_length

    
    


def main():

    xlim,ylim = (0, 100),(0,100)
    start = (25, 50)
    goal = (75, 50)
    step_size = 2.5
    trials_number = 100

    # scenario 1
    #obstacles = [((25,37.5),(20,5)), ((25,62.5),(20,5)), ((37.5,50),(5,30)), ((12.5,41.5),(5,13)), ((12.5,58.5),(5,13))] 
    # scenario 2
    #obstacles = [((75,37.5),(20,5)), ((75,62.5),(20,5)), ((62.5,50),(5,30)), ((87.5,41.5),(5,13)), ((87.5,58.5),(5,13))] 
    # scenario 3
    obstacles = [((25,37.5),(20,5)), ((25,62.5),(20,5)), ((37.5,50),(5,30)), ((12.5,41.5),(5,13)), ((12.5,58.5),(5,13)), 
                 ((75,37.5),(20,5)), ((75,62.5),(20,5)), ((62.5,50),(5,30)), ((87.5,41.5),(5,13)), ((87.5,58.5),(5,13))] 
    
    iterations_list = np.zeros(trials_number,dtype=float)
    vertices_list = np.zeros(trials_number,dtype=float)
    solution_length_list = np.zeros(trials_number,dtype=float)
    
    
    
    iterations, vertices, solution_length = build_RRT_CONNECT(start,goal,xlim,ylim,obstacles,step_size
                                                      ,trial = 0,plot = True)
    
    iterations_list[0] = iterations
    vertices_list[0] = vertices
    solution_length_list[0] = solution_length
    print("Trial:",1)
    

    for trial in range(1,trials_number):

        iterations, vertices, solution_length = build_RRT_CONNECT(start,goal,xlim,ylim,obstacles,step_size,trial)
    
        iterations_list[trial] = iterations
        vertices_list[trial] = vertices
        solution_length_list[trial] = solution_length
        print("Trial:",trial+1)

    iterations_median = np.median(iterations_list)
    vertices_median = np.median(vertices_list)
    solution_length_median = np.median(solution_length_list)

    print("Iterations median:",iterations_median)
    print("Vertices median:",vertices_median)
    print("Solution length median:", solution_length_median)



if __name__ == "__main__":
    main()